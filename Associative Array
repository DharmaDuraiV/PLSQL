üîπ What is an Associative Array?
An associative array is a key-value collection stored only in PL/SQL memory.

Index can be:

NUMBER
VARCHAR2
Size is dynamic
Fast access
Cannot be stored in database tables

üîπ Why Learn This First?

‚úî Easiest
‚úî No database objects required
‚úî Best for temporary data processing

üîπ Syntax
TYPE type_name IS TABLE OF datatype
INDEX BY index_type;

collection_name type_name;

--------------------------------------------------------

üîπ Simple Example (BEGINNER)


DECLARE
  TYPE emp_name_tab IS TABLE OF VARCHAR2(50)
  INDEX BY PLS_INTEGER;

  emp_names emp_name_tab;
BEGIN
  emp_names(1) := 'Ravi';
  emp_names(2) := 'Kumar';

  DBMS_OUTPUT.PUT_LINE(emp_names(1));
  DBMS_OUTPUT.PUT_LINE(emp_names(2));
END;
/

1Ô∏è‚É£ DATATYPE (What can be stored?)

You can store almost any PL/SQL datatype as the element type.

‚úÖ Allowed DATATYPES
üî∏ Scalar Types

NUMBER
VARCHAR2
CHAR
DATE
BOOLEAN
PLS_INTEGER
BINARY_INTEGER

TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;

üî∏ %TYPE
TYPE name_tab IS TABLE OF emp.ename%TYPE INDEX BY PLS_INTEGER;

üî∏ RECORD Type
TYPE emp_rec IS RECORD (
  empno emp.empno%TYPE,
  ename emp.ename%TYPE
);

TYPE emp_tab IS TABLE OF emp_rec INDEX BY PLS_INTEGER;

üî∏ %ROWTYPE
TYPE emp_tab IS TABLE OF emp%ROWTYPE INDEX BY PLS_INTEGER;

üî∏ Object Type
TYPE emp_obj IS OBJECT (
  empno NUMBER,
  ename VARCHAR2(30)
);

TYPE obj_tab IS TABLE OF emp_obj INDEX BY PLS_INTEGER;

üî∏ Nested Collection Types
TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
TYPE nested_tab IS TABLE OF num_tab INDEX BY PLS_INTEGER;

‚ùå NOT Allowed as DATATYPE

LONG
LONG RAW
ROWID (directly, avoid)
CLOB / BLOB (restricted usage)
XMLTYPE (not recommended)

2Ô∏è‚É£ INDEX_TYPE (What can be used as KEY?)

This defines the KEY of the associative array.

‚úÖ Allowed INDEX_TYPES

| Index Type       | Allowed? | Notes              |
| ---------------- | -------- | ------------------ |
| `PLS_INTEGER`    | ‚úÖ BEST   | Fastest, most used |
| `BINARY_INTEGER` | ‚úÖ        | Older              |
| `INTEGER`        | ‚ùå        | Not allowed        |
| `VARCHAR2`       | ‚úÖ        | String-based index |
| `STRING`         | ‚ùå        | Not allowed        |
| `NUMBER`         | ‚ùå        | Not allowed        |



‚úî Numeric Index Example
TYPE sal_tab IS TABLE OF NUMBER
INDEX BY PLS_INTEGER;

v_sal sal_tab;
BEGIN
  v_sal(1) := 3000;
  v_sal(2) := 4000;
END;

‚úî String Index Example
TYPE emp_name_tab IS TABLE OF emp.empno%TYPE
INDEX BY VARCHAR2(30);

v_emp emp_name_tab;
BEGIN
  v_emp('SMITH') := 7369;
  v_emp('ALLEN') := 7499;
END;

3Ô∏è‚É£ MOST IMPORTANT COMBINATIONS (Interview Focus)
üî• Best Practice
TYPE t_tab IS TABLE OF emp%ROWTYPE
INDEX BY PLS_INTEGER;

üî• Record + Index
TYPE emp_tab IS TABLE OF emp_rec
INDEX BY PLS_INTEGER;

üî• String Key Lookup
TYPE dept_tab IS TABLE OF dept.deptno%TYPE
INDEX BY VARCHAR2(20);

üîπ Key Methods

| Method      | Meaning            |
| ----------- | ------------------ |
| `COUNT`     | Number of elements |
| `FIRST`     | First index        |
| `LAST`      | Last index         |
| `NEXT(i)`   | Next index         |
| `PRIOR(i)`  | Previous index     |
| `EXISTS(i)` | Check index exists |
| `DELETE`    | Remove elements    |


üîπ 1Ô∏è‚É£ COUNT ‚Äì Number of Elements
üëâ Meaning

Returns how many elements exist in the collection.

üß™ Example
DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
BEGIN
  nums(1) := 10;
  nums(2) := 20;
  nums(5) := 50;

  DBMS_OUTPUT.PUT_LINE('Total Elements: ' || nums.COUNT);
END;
/

‚úÖ Output
Total Elements: 3


üìå Note: Index gaps don‚Äôt matter.


üîπ 2Ô∏è‚É£ FIRST ‚Äì First Index
üëâ Meaning

Returns the lowest index VALUE in the collection.

üß™ Example
DECLARE
  TYPE emp_tab IS TABLE OF VARCHAR2(50) INDEX BY PLS_INTEGER;
  emp emp_tab;
BEGIN
  emp(10) := 'Ravi';
  emp(20) := 'Kumar';

  DBMS_OUTPUT.PUT_LINE('First Index: ' || emp.FIRST);
END;
/

‚úÖ Output
First Index: 10


üîπ 3Ô∏è‚É£ LAST ‚Äì Last Index
üëâ Meaning

Returns the highest index in the collection.

üß™ Example
DECLARE
  TYPE emp_tab IS TABLE OF VARCHAR2(50) INDEX BY PLS_INTEGER;
  emp emp_tab;
BEGIN
  emp(100) := 'A';
  emp(200) := 'B';

  DBMS_OUTPUT.PUT_LINE('Last Index: ' || emp.LAST);
END;
/

‚úÖ Output
Last Index: 200


üîπ 4Ô∏è‚É£ NEXT(i) ‚Äì Next Index
üëâ Meaning

Returns the next valid index after i.

üß™ Example
DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
  i PLS_INTEGER;
BEGIN
  nums(5)  := 100;
  nums(10) := 200;
  nums(50) := 300;

  i := nums.FIRST;
  DBMS_OUTPUT.PUT_LINE('Current: ' || i);
  DBMS_OUTPUT.PUT_LINE('Next: ' || nums.NEXT(i));
END;
/

‚úÖ Output
Current: 5
Next: 10


üìå If no next index ‚Üí returns NULL.

üîπ 5Ô∏è‚É£ PRIOR(i) ‚Äì Previous Index
üëâ Meaning

Returns the previous valid index before i.

üß™ Example
DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
BEGIN
  nums(1)  := 10;
  nums(5)  := 50;
  nums(20) := 200;

  DBMS_OUTPUT.PUT_LINE('Previous of 20: ' || nums.PRIOR(20));
END;
/

‚úÖ Output
Previous of 20: 5

üîπ 6Ô∏è‚É£ EXISTS(i) ‚Äì Check Index Exists
üëâ Meaning

Returns TRUE if index exists, else FALSE.

üß™ Example
DECLARE
  TYPE emp_tab IS TABLE OF VARCHAR2(30) INDEX BY PLS_INTEGER;
  emp emp_tab;
BEGIN
  emp(1) := 'Dharma';

  IF emp.EXISTS(1) THEN
    DBMS_OUTPUT.PUT_LINE('Index 1 exists');
  END IF;

  IF NOT emp.EXISTS(5) THEN
    DBMS_OUTPUT.PUT_LINE('Index 5 does NOT exist');
  END IF;
END;
/

‚úÖ Output
Index 1 exists
Index 5 does NOT exist


üìå Very useful to avoid NO_DATA_FOUND errors.


üîπ 7Ô∏è‚É£ DELETE ‚Äì Remove Elements
üëâ Meaning

Deletes elements from collection.

üß™ Example 1: Delete ONE element
DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
BEGIN
  nums(1) := 10;
  nums(2) := 20;
  nums(3) := 30;
  nums(4) := 40;
  nums(5) := 50;

  nums.DELETE(1);

  DBMS_OUTPUT.PUT_LINE('Count after delete: ' || nums.COUNT);
END;
/

‚úÖ Output
Count after delete: 4

üß™ Example 2: Delete RANGE

DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
BEGIN
  nums(1) := 10;
  nums(2) := 20;
  nums(3) := 30;
  nums(4) := 40;
  nums(5) := 50;

  nums.DELETE(1, 3);

  DBMS_OUTPUT.PUT_LINE('Count after delete: ' || nums.COUNT);
END;
/

Count after delete: 2

üß™ Example 3: Delete ALL


DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
BEGIN
  nums(1) := 10;
  nums(2) := 20;
  nums(3) := 30;
  nums(4) := 40;
  nums(5) := 50;

  nums.DELETE;

  DBMS_OUTPUT.PUT_LINE('Count after delete: ' || nums.COUNT);
END;
/

Count after delete: 0

-----------------------------------------------------------------------------------

Real Loop Using ALL METHODS
---------------------------
DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
  i PLS_INTEGER;
BEGIN
  nums(2) := 20;
  nums(5) := 50;
  nums(10) := 100;

  i := nums.FIRST;
  WHILE i IS NOT NULL LOOP
    DBMS_OUTPUT.PUT_LINE(nums(i));
    i := nums.NEXT(i);
  END LOOP;
END;
/

DECLARE
  TYPE num_tab IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  nums num_tab;
  i PLS_INTEGER;
  L PLS_INTEGER;
BEGIN
  nums(2) := 20;
  nums(5) := 50;
  nums(10) := 100;

  i := nums.FIRST;
  L := nums.LAST;

  FOR val IN i..L LOOP
    IF nums.EXISTS(val) THEN
      DBMS_OUTPUT.PUT_LINE(nums(val));
    END IF;
  END LOOP;
END;
/

