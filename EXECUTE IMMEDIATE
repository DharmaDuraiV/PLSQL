

# ğŸ“˜ EXECUTE IMMEDIATE in PL/SQL â€“ Complete Notes

---

## 1ï¸âƒ£ What is EXECUTE IMMEDIATE?

`EXECUTE IMMEDIATE` is a **PL/SQL statement** used to execute **Dynamic SQL** â€” SQL statements that are **constructed and executed at runtime**.

ğŸ‘‰ Introduced as part of **Native Dynamic SQL (NDS)**.

---

## 2ï¸âƒ£ Why Dynamic SQL is Needed?

PL/SQL is **compiled language**, so it:

* Cannot accept **dynamic table names**
* Cannot execute **DDL statements directly**
* Cannot handle **runtime-built SQL**

### Examples where static SQL fails:

âŒ Table name is variable
âŒ Column name is variable
âŒ CREATE / DROP / ALTER inside PL/SQL
âŒ Runtime conditional SQL

â¡ï¸ Solution: **EXECUTE IMMEDIATE**

---

## 3ï¸âƒ£ What Can EXECUTE IMMEDIATE Execute?

| SQL Type                            | Supported          |
| ----------------------------------- | ------------------ |
| DDL (CREATE, DROP, ALTER, TRUNCATE) | âœ…                  |
| DML (INSERT, UPDATE, DELETE)        | âœ…                  |
| SELECT (single row)                 | âœ…                  |
| PL/SQL blocks                       | âœ…                  |
| SELECT (multiple rows)              | âŒ (Use REF CURSOR) |

---

## 4ï¸âƒ£ Basic Syntax

```sql
EXECUTE IMMEDIATE sql_string;
```

Where `sql_string` is a **VARCHAR2 or CLOB**.

---

## 5ï¸âƒ£ Executing DDL Statements (Most Common Use)

```sql
BEGIN
  EXECUTE IMMEDIATE 'CREATE TABLE emp_backup (
    emp_id NUMBER,
    emp_name VARCHAR2(50)
  )';
END;
/
```

ğŸ“Œ **Important Rule**
DDL statements **CANNOT** be executed directly in PL/SQL â†’ `EXECUTE IMMEDIATE` is mandatory.

---

## 6ï¸âƒ£ Dynamic DML Example (INSERT / UPDATE / DELETE)

### DELETE Example

```sql
DECLARE
  v_sql VARCHAR2(200);
BEGIN
  v_sql := 'DELETE FROM employees WHERE dept_id = 10';
  EXECUTE IMMEDIATE v_sql;
END;
/
```

---

## 7ï¸âƒ£ Bind Variables (VERY IMPORTANT â€“ Interview Favorite â­)

### âŒ Bad Practice (SQL Injection risk)

```sql
EXECUTE IMMEDIATE
'DELETE FROM employees WHERE dept_id = ' || v_dept;
```

### âœ… Best Practice Using Bind Variables

```sql
DECLARE
  v_dept NUMBER := 20;
BEGIN
  EXECUTE IMMEDIATE
    'DELETE FROM employees WHERE dept_id = :id'
  USING v_dept;
END;
/
```

### Advantages of Bind Variables:

* âœ… Prevents SQL Injection
* âœ… Better performance (soft parsing)
* âœ… Secure coding standard

---

## 8ï¸âƒ£ SELECT INTO with EXECUTE IMMEDIATE

Used when the query returns **ONLY ONE ROW & ONE COLUMN**.

```sql
DECLARE
  v_count NUMBER;
BEGIN
  EXECUTE IMMEDIATE
    'SELECT COUNT(*) FROM employees'
  INTO v_count;

  DBMS_OUTPUT.PUT_LINE(v_count);
END;
/
```

ğŸš¨ If query returns **multiple rows â†’ ERROR**

---

## 9ï¸âƒ£ Dynamic Table Name (Very Common Real-Time Case)

```sql
DECLARE
  v_table_name VARCHAR2(30) := 'employees';
  v_count NUMBER;
BEGIN
  EXECUTE IMMEDIATE
    'SELECT COUNT(*) FROM ' || v_table_name
  INTO v_count;

  DBMS_OUTPUT.PUT_LINE(v_count);
END;
/
```

ğŸ“Œ **Rule**
Table & column names **CANNOT be bind variables**.

---

## ğŸ”Ÿ Executing PL/SQL Block Dynamically

```sql
BEGIN
  EXECUTE IMMEDIATE
    'BEGIN
       DBMS_OUTPUT.PUT_LINE(''Hello World'');
     END;';
END;
/
```

---

## 1ï¸âƒ£1ï¸âƒ£ Calling Stored Procedure Dynamically

```sql
BEGIN
  EXECUTE IMMEDIATE
    'BEGIN update_salary(101, 5000); END;';
END;
/
```

---

## 1ï¸âƒ£2ï¸âƒ£ Multiple Bind Variables Example

```sql
DECLARE
  v_id NUMBER := 101;
  v_sal NUMBER := 8000;
BEGIN
  EXECUTE IMMEDIATE
    'UPDATE employees SET salary = :sal WHERE emp_id = :id'
  USING v_sal, v_id;
END;
/
```

ğŸ“Œ Bind variables are mapped **by position**, not name.

---

## 1ï¸âƒ£3ï¸âƒ£ Using OUT Bind Variables

```sql
DECLARE
  v_count NUMBER;
BEGIN
  EXECUTE IMMEDIATE
    'SELECT COUNT(*) FROM employees'
  INTO v_count;

  DBMS_OUTPUT.PUT_LINE(v_count);
END;
/
```

---

## 1ï¸âƒ£4ï¸âƒ£ Handling Errors with EXECUTE IMMEDIATE

```sql
BEGIN
  EXECUTE IMMEDIATE 'DROP TABLE emp_backup';
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLERRM);
END;
/
```

---

## 1ï¸âƒ£5ï¸âƒ£ EXECUTE IMMEDIATE vs DBMS_SQL

| Feature       | EXECUTE IMMEDIATE | DBMS_SQL  |
| ------------- | ----------------- | --------- |
| Ease of use   | âœ… Easy            | âŒ Complex |
| Performance   | âœ… Faster          | âŒ Slower  |
| Static typing | âœ…                 | âŒ         |
| Recommended   | âœ… YES             | âŒ Old     |

ğŸ“Œ **Use `EXECUTE IMMEDIATE` unless you need very complex dynamic logic**

---

## 1ï¸âƒ£6ï¸âƒ£ When NOT to Use EXECUTE IMMEDIATE

âŒ Static SQL
âŒ Normal SELECT statements
âŒ Fixed DML without dynamic elements

Example:

```sql
SELECT * FROM employees;  -- DO NOT use EXECUTE IMMEDIATE
```

---

## 1ï¸âƒ£7ï¸âƒ£ Real-Time Use Cases

âœ” Dynamic report generation
âœ” Audit table creation
âœ” Multi-tenant architecture
âœ” Runtime schema operations
âœ” Admin panels
âœ” Generic CRUD procedures

---

## 1ï¸âƒ£8ï¸âƒ£ Common Interview Questions

### Q1. Why DDL needs EXECUTE IMMEDIATE?

â¡ï¸ Because DDL causes **implicit commit** and cannot be compiled in PL/SQL.

### Q2. Can we use bind variables for table names?

â¡ï¸ âŒ No.

### Q3. How to fetch multiple rows?

â¡ï¸ Use **REF CURSOR**, not `EXECUTE IMMEDIATE INTO`.

---

## 1ï¸âƒ£9ï¸âƒ£ One-Line Interview Answer â­

> **EXECUTE IMMEDIATE** is used in PL/SQL to execute **dynamic SQL statements**, including **DDL, DML, and runtime-generated queries**, using **Native Dynamic SQL**.

---

## 2ï¸âƒ£0ï¸âƒ£ Quick Revision Chart

| Feature              | Supported |
| -------------------- | --------- |
| Dynamic SQL          | âœ…         |
| DDL execution        | âœ…         |
| Bind variables       | âœ…         |
| Multiple rows SELECT | âŒ         |
| Secure coding        | âœ…         |

---

If you want next, I can give you:

* ğŸ“Œ **EXECUTE IMMEDIATE with REF CURSOR**
* ğŸ“Œ **Banking / OTP / Audit Log real-time examples**
* ğŸ“Œ **Interview problems + answers**
* ğŸ“Œ **PDF notes format**

Just tell me ğŸ‘
