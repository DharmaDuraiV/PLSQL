			plsql

ÔÉ®	Pl/sql  is a procedural language extension for sql.
ÔÉ®	A procedural programming language is a type of programming language that follows a step-by-step, sequential approach to solve problems
ÔÉ®	It is the combination of procedural ,data manuplation language.
ÔÉ®	PL/SQL = Procedural Language (like logic, loops) + SQL (DML)
ÔÉ®	So you can control the flow of a program and also manipulate data in one place.
ÔÉ®	Oracle 6.0 introduced pl/sql :

TO VIEW VERSION OF  PL/SQL.

SELECT * 
FROM V$VERSION ;

BASICALLY PL/SQL IS A BLOCK STRUCTURED:

DECLARE [OPTIONAL]
 VARIABLE DECLARATION ,
 CURSORS,
 EXCEPTIONS 
BEGIN [ MANDATORY ]
 DML ,TCL 
 SELECT ____ INTO __ 
 CONDITIONAL ,
 CONTROL STATEMENTS ;
EXCEPTION [ OPTIONAL ]
 HANDLING EXCEPTIONS
END ; [ MANDATORY ]
/


There are two types of blocks supported by pl/sql :
	1.ANNOYMOUS BLOCK 
	2. NAMED BLOCK 

ANNOYMOUS BLOCK:

‚úÖ Anonymous Block in PL/SQL :

‚ùå Anonymous blocks do not have a name.

üóëÔ∏è They are not stored in the database (used only once, temporary).

üö´ You cannot call them from other blocks or applications.

‚úÖ Used for testing, small tasks, or quick scripts.


SYNTAX  :

	DECLARE
	  -- Variable declarations (optional)
	BEGIN
	  -- Your PL/SQL logic here
	END;
	/


 NAMED BLOCK:

üß± Named blocks are PL/SQL code blocks that have a name (like a saved program).

üóÇÔ∏è They are stored in the Oracle database, so you don‚Äôt need to write them again and again.

üîÅ You can reuse them by calling their name anywhere in your application.

üë®‚Äçüíª Used by developers to keep code organized, clean, and modular (broken into parts).

‚úÖ Very useful in big applications where the same logic is needed in many places.

üìö Types of Named Blocks:

	| Type             | Description                                          |
	| ---------------- | ---------------------------------------------------- |
	| Procedure 	   | Performs a task (may or may not return value)        |
	| Function	   | Must return a value                                  |
	| Trigger          | Runs **automatically** on insert/update/delete       |
	| Package          | Collection of related procedures/functions/variables |
	| Package Body     | Contains the actual code for the package items       |



VARIABLE 

üì¶ A variable is a named storage used to hold a single value in memory.

üß† It allows you to store, change, and use values during program execution.

üßÆ The value stored in a variable can be number, text, date, etc.


SYNTAX: 
	VARIABLE_NAME DATATYPE(SIZE);

EXAMPLE:

	V_NAME VARCHAR(20) ;

 Generally we are declaring variable in declare section of pl/sql blocks .

     EXAMPLES:

	DECLARE 
	     V_NAME VARCHAR(20);
	     V_AGE NUMBER(2);
	     V_SAL NUMBER(7);


HOW TO STORE THE VALUES INTO PL/SQL VARIABLE.

	We use the assignment operator := to assign or store values into PL/SQL variables.

       SYNTAX:
		VARIABLE_NAME := VALUE ;
     EXAMPLE:
		V_AGE := 60 ;

TO DISPLAY THE MESSAGES :

	DBMS_OUTPUT.PUT_LINE( 'MESSAGES');
	DBMS_OUTPUT.PUT_LINE( V_AGE);

TO DISPLAY ANY RESULT WITH IN THE PLSQL BLOCKS:

	SET SERVEROUTPUT ON ;
EXAMPLE1: 
	BEGIN
  	   DBMS_OUTPUT.PUT_LINE( 'HELLO WORLD');
	END ;
	/
O/P:
	HELLO WORLD	

EXAMPLE2: 
	DECLARE 
	 V_NAME VARCHAR(20) := 'ARCHANA' ;
	BEGIN
  	   DBMS_OUTPUT.PUT_LINE( 'WELCOME TO PLSQL WORLD :'||V_NAME);
	END ;
	/
O/P:

WELCOME TO PLSQL WORLD :ARCHANA

----------------------------------------------------------
	DECLARE 
	 V_NAME VARCHAR(20) := '&V_NAME' ;
	BEGIN
  	   DBMS_OUTPUT.PUT_LINE( 'WELCOME TO PLSQL WORLD :'||V_NAME);
	END ;
	/

TASK : 
 1) Write a PL/SQL block that declares a variable v_city, stores the value 'Chennai' into it, and displays it.
 2) Declare two variables a and b, assign values 10 and 20, calculate the sum and display the result.
 3) Write an anonymous block that declares a variable for your name and prints a welcome message like:
    EXAMPLE : 
        OUTPUT :  Welcome, Dharma!
 4) Create a PL/SQL block that uses := to assign the value 'PL/SQL is powerful' to a variable and prints it.
 5) Write a PL/SQL block with a nested block inside. Declare a variable in the outer block (v_outer) and another in the inner block (v_inner). Print both values inside the inner block.
