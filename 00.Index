What is an Index? 

   üîπIndex is a database object that improves query performance by providing quick access to rows in a table.
   üîπ It allows faster retrieval of data, especially for large tables.
   üîπ It works similarly to an index in a book, helping you quickly locate specific rows.
   üîπ Indexes are automatically created on primary key and unique key columns.


Advantages of Indexes:
---------------------------
    üîπ Faster Query Performance: Speeds up data retrieval, especially for SELECT queries with WHERE clauses.
    üîπ Can be unique or non-unique.

Types of Index :
   üîπClustered Index
   üîπNon-Clustered Index
----------------------------------------------------------------------------------
Non-Clustered Index:
    üîπ A non-clustered index is an index structure that is stored separately from the table data.
    üîπ It contains index keys + ROWID pointers to the actual rows in the table.
    üîπ When a query uses the index, Oracle first looks up the ROWID in the index ‚Üí then retrieves the actual row from the table.
    üîπIn Oracle, every normal index you create with CREATE INDEX is non-clustered by default.

     Types of Index 
           1. Single-Column Index
           2. Composite (Multi-Column) Index
           3. Unique Index
           4. Function-Based Index
           5. Reverse Index (Reverse Key Index)
           6. Bitmap Index
------------------------------------------------------------------------

1Ô∏è‚É£ Single-column Index:
************************
üîπ Built on one column.
üîπ Allows duplicate values.
üîπ Used to improve performance of queries (WHERE conditions).

Syntax:

     CREATE INDEX index_name
     ON table_name (column_name);

Examples 
---------

     CREATE INDEX index_sal
     ON emp (sal);

****************************************************************************************************************************

2Ô∏è‚É£ Composite Index (on multiple columns):
----------------------------------------------

   üîπ Built on multiple columns.
   üîπ Order of columns matters in query optimization.

Syntax :

     CREATE INDEX index_name
     ON table_name (column_name1, column_name2);

Examples 
--------

     CREATE INDEX ind_name_dno
     ON emp (ename, deptno);

****************************************************************************************************************************

3Ô∏è‚É£ Unique Index:
--------------------

üîπ Ensures no duplicate values in the column(s).
üîπ Usually created automatically when you define a PRIMARY KEY or UNIQUE constraint.

Syntax:

     CREATE UNIQUE INDEX index_name
     ON table_name (column_name);

Examples
---------

    CREATE TABLE CUST 
    (
    CID NUMBER(4) ;
    CNAME VARCHAR(20) ,
    ADDRESS VARCHAR(50) 
   ) ;

     CREATE UNIQUE INDEX IND_CUST_CID
     ON CUST (CID) ;

   INSERT INTO CUST VALUES (1 ,'A' ,'BANGALORE');
   INSERT INTO CUST VALUES (2 , 'B' ,'CHENNAI' );
   INSERT INTO CUST VALUES (1, 'C' ,'MANDYA' );

****************************************************************************************************************************
4Ô∏è‚É£ Function-Based Index
   ----------------------

  üîπ Index created on an expression or function of a column.
  üîπ Useful when queries use functions on columns.

Syntax :

   CREATE INDEX Index_name
   ON Table_Name(SRF(COL_NAME)/EXPRESSION);

EXAMPLE :

   CREATE INDEX idx_upper_name
   ON emp(UPPER(ename));

OR 

   CREATE INDEX idx_Annual_salary
   ON emp(sal*12);

****************************************************************************************************************************
5Ô∏è‚É£ Reverse Index (Reverse Key Index)

   üîπ Stores index key values in reverse byte order.
   üîπ Helps avoid block contention when inserting sequential values (like from a sequence).

Syntax:

   CREATE INDEX index_name
   ON table_name(column_name) REVERSE;


Example:

   CREATE INDEX idx_emp_rev
   ON emp(empno) REVERSE;

****************************************************************************************************************************

6Ô∏è‚É£ Bitmap Index

  üîπ Stores rowids as bitmaps (0/1).
  üîπ Very efficient for low-cardinality columns (few distinct values, e.g., Gender, Status).

Syntax:

   CREATE BITMAP INDEX index_name
   ON table_name(column_name);


Example:

   CREATE BITMAP INDEX idx_emp_gender
   ON employees(gender);

****************************************************************************************************************************
Cluster :- 
   A Cluster is a Database object that allows storing data from two or more tables together in the same data block based on common column(s).
   Improves performance of queries that join related tables frequently.
   Reduces I/O operations by keeping related rows physically close.
   Efficient storage for related rows.

Step 1: Create the Cluster (define cluster key)
-----------------------------------------------

CREATE CLUSTER emp_dept_cluster (
  deptno NUMBER(2)
);

Step 2: Create Cluster Index (required for INDEX cluster)
-----------------------------------------------

CREATE INDEX idx_emp_dept_cluster
ON CLUSTER emp_dept_cluster;

Step 3: Create Tables inside the Cluster
-----------------------------------------------

-- Dept table inside cluster
CREATE TABLE dept44 (
  deptno NUMBER(2) PRIMARY KEY,
  dname  VARCHAR2(14),
  loc    VARCHAR2(13)
) CLUSTER emp_dept_cluster (deptno);

-- Emp table inside cluster with foreign key
CREATE TABLE emp44 (
  empno  NUMBER(4) PRIMARY KEY,
  ename  VARCHAR2(10),
  job    VARCHAR2(9),
  deptno NUMBER(2) NOT NULL,
  CONSTRAINT fk_emp_dept FOREIGN KEY (deptno) 
     REFERENCES dept44(deptno)
) CLUSTER emp_dept_cluster (deptno);

Step 4: Insert Sample Data
-----------------------------------------------

INSERT INTO dept44 VALUES (10, 'ACCOUNTING', 'NEW YORK');
INSERT INTO dept44 VALUES (20, 'RESEARCH',   'DALLAS');

INSERT INTO emp44 VALUES (7369, 'SMITH',  'CLERK',   20);
INSERT INTO emp44 VALUES (7499, 'ALLEN',  'SALESMAN',10);
INSERT INTO emp44 VALUES (7521, 'WARD',   'SALESMAN',10);
INSERT INTO emp44 VALUES (7566, 'JONES',  'MANAGER', 20);
COMMIT;

Step 5: Query (joins benefit from clustering)
-----------------------------------------------

SELECT *
FROM   emp e
JOIN   dept d ON d.deptno = e.deptno
ORDER BY d.deptno, e.empno;

Step 6: Drop Objects
-----------------------------------------------
DROP TABLE emp PURGE;
DROP TABLE dept PURGE;
DROP INDEX idx_emp_dept_cluster;
DROP CLUSTER emp_dept_cluster INCLUDING TABLES;


***********************************************************************************
 




