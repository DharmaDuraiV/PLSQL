
Nested Table
-------------

What is a Nested Table?

 ğŸ”¹ A Nested Table is a PL/SQL collection type that:
 ğŸ”¹ Stores multiple values of the same datatype
 ğŸ”¹ Has no fixed size
 ğŸ”¹ Can be stored in a database table column
 ğŸ”¹ Allows DELETE of any element

ğŸ‘‰ Think of it as a table inside a variable or column.

Why do we need Nested Tables?

Real company problems they solve:

| Problem                           | Without Nested Table   | With Nested Table    |
| --------------------------------- | ---------------------- | -------------------- |
| One customer â†’ many phone numbers | Multiple rows          | One row + collection |
| One order â†’ many items            | Join tables everywhere | Clean structure      |
| One employee â†’ many skills        | Extra table required   | Single column        |
| Pass multiple values to procedure | Repeated calls         | One parameter        |


ğŸ‘‰ Used when 1 row logically contains multiple values

ğŸ§  Key Features (Important for Interview)

  âœ” Dynamic size
  âœ” Index starts from 1
  âœ” Supports DELETE
  âœ” Can be stored in table column
  âŒ No guaranteed order

Syntax
1ï¸âƒ£ Type Declaration
TYPE type_name IS TABLE OF datatype;

2ï¸âƒ£ Variable Declaration
variable_name type_name;


Basic Example (Beginner Level)

Example: Store multiple marks of a student

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab(85, 90, 78, 88);
BEGIN
  DBMS_OUTPUT.PUT_LINE('First Mark: ' || v_marks(1));
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

Output
First Mark: 85
Total Subjects: 4


ğŸ”§ Common Methods Used

| Method      | Meaning            |
| ----------- | ------------------ |
| `COUNT`     | Number of elements |
| `EXTEND`    | Add new element    |
| `DELETE`    | Remove element     |
| `FIRST`     | First index        |
| `LAST`      | Last index         |
| `EXISTS(i)` | Check index exists |

ğŸ“˜ PL/SQL Nested Table â€“ EXTEND, COUNT
------------------------------------------

Example 1: Empty Nested Table â€“ No Data
---------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab();
BEGIN
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

  ğŸ”¹ Nested table is initialized but no elements are added.
  ğŸ”¹ COUNT returns number of elements present.

âœ… Output

Total Subjects: 0

------------------------------------------------------------------------------------

Example 2: Assigning Value Without EXTEND âŒ
------------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab();
BEGIN
  v_marks(1) := 1;
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

Nested table is empty.
You are directly assigning v_marks(1) without extending memory.
Nested tables do not auto-expand.

âœ… Output

âŒ Error
ORA-06533: Subscript beyond count

------------------------------------------------------------------------------------

ğŸ”¹ Example 3: Correct Usage with EXTEND
------------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab();
BEGIN
  v_marks.EXTEND;
  v_marks(1) := 1;
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

EXTEND adds 1 empty element.
Index 1 now exists.
Value assignment succeeds.

âœ… Output

Total Subjects: 1

------------------------------------------------------------------------------------

ğŸ”¹ Example 4: EXTEND Only Once, Assign Index 5 âŒ
------------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab();
BEGIN
  v_marks.EXTEND;
  v_marks(5) := 1;
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

EXTEND adds only index 1
Index 5 does not exist

âœ… Output

âŒ Error
ORA-06533: Subscript beyond count
------------------------------------------------------------------------------------

ğŸ”¹ Example 5: EXTEND(5) â€“ Valid Assignment
------------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab();
BEGIN
  v_marks.EXTEND(5);
  v_marks(5) := 1;
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

EXTEND(5) creates indexes 1 to 5
Index 5 exists â†’ assignment allowed

âœ… Output

Total Subjects: 5

------------------------------------------------------------------------------------
ğŸ”¹ Example 6: Initialized Table + EXTEND
------------------------------------------

DECLARE
  TYPE marks_tab IS TABLE OF NUMBER;
  v_marks marks_tab := marks_tab(45,50,78);
BEGIN
  v_marks.EXTEND(5);
  v_marks(5) := 1;
  DBMS_OUTPUT.PUT_LINE('Total Subjects: ' || v_marks.COUNT);
END;
/

ğŸ” Explanation

Initially: 45, 50, 78 â†’ COUNT = 3
EXTEND(5) adds 5 more empty elements
Total elements = 3 + 5 = 8
Assigning index 5 is valid

âœ… Output

Total Subjects: 8
------------------------------------------------------------------------------------

ğŸ”„ Example with Methods

DECLARE
  TYPE num_tab IS TABLE OF NUMBER;
  v_num num_tab := num_tab(10, 20, 30);
BEGIN
  v_num.EXTEND;
  v_num(4) := 40;
 for i in v_num.first .. v_num.last loop
   DBMS_OUTPUT.PUT_LINE('nested tab index '|| i ||' value is ' || v_num(i));
 end loop;
  v_num.DELETE(2); -- deletes value 20
  IF v_num.EXISTS(2) THEN
    DBMS_OUTPUT.PUT_LINE('Index 2 exists');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Index 2 deleted');
  END IF;
 DBMS_OUTPUT.PUT_LINE('Total number of Tabs '||v_num.count);
  v_num(2) := 47 ;
 DBMS_OUTPUT.PUT_LINE('Total number of Tabs '||v_num.count);
END;
/
------------------------------------------------------------------------------------


ğŸ¢ High-Level Example (Company Standard):
------------------------------------------

ğŸ¦ Scenario: One Employee â†’ Multiple Skills

âœ… CREATE OR REPLACE TYPE (Nested Table)
ğŸ”¹ Syntax
CREATE OR REPLACE TYPE type_name IS TABLE OF datatype;
/

ğŸ”¹ Your Example
CREATE OR REPLACE TYPE skill_tab IS TABLE OF VARCHAR2(50);
/


âœ” Replaces the existing type if it exists
âœ” Creates it if it does not exist

ğŸ—‚ï¸ Oracle Version Support (VERY IMPORTANT)

| Oracle Version | Support         |
| -------------- | --------------- |
| 11g and below  | âŒ NOT supported |
| **12c**        | âœ… Supported     |
| **18c**        | âœ… Supported     |
| **19c**        | âœ… Supported     |
| **21c**        | âœ… Supported     |
| **23c**        | âœ… Supported     |

ğŸ‘‰ Introduced in Oracle 12c

âš ï¸ RULES (Company / Interview Critical)
âœ… Allowed When:
-----------------

No dependent table has data OR
Change is compatible
Same datatype
Size increase (VARCHAR2(50 â†’ 100))

CREATE OR REPLACE TYPE skill_tab IS TABLE OF VARCHAR2(100);
/
âœ” Works in many cases

âŒ NOT Allowed When:
---------------------

Type is used in a table column with data
Change breaks structure

CREATE OR REPLACE TYPE skill_tab IS TABLE OF NUMBER;
/


âŒ Error:

ORA-02303: cannot drop or replace a type with table dependents


ğŸ” What Happens Internally
-----------------------------------

Oracle checks dependencies
Oracle validates compatibility
If safe â†’ replaces definition
If unsafe â†’ throws error

ğŸ¢ Company Standard Usage
Development Environment

âœ” Use CREATE OR REPLACE TYPE

Production Environment

âŒ Avoid direct replace
âœ” Use:
skill_tab_v2

âœ” Controlled migration

------------------------------------------------------------
âœ… 1ï¸âƒ£ List ALL TYPEs in your schema (MOST COMMON)
SELECT type_name
FROM user_types;


âœ” Shows all user-defined TYPEs
âœ” Used in day-to-day development

âœ… 2ï¸âƒ£ Check a Specific TYPE (your case: SKILL_TAB)
SELECT type_name, typecode
FROM user_types
WHERE type_name = 'SKILL_TAB';

Output Example
SKILL_TAB   COLLECTION


ğŸ‘‰ COLLECTION = Nested Table / VARRAY
ğŸ‘‰ OBJECT = Object Type

âœ… 3ï¸âƒ£ See TYPE Definition (VERY IMPORTANT)
SELECT text
FROM user_source
WHERE name = 'SKILL_TAB'
ORDER BY line;


âœ” Shows exact CREATE TYPE code
âœ” Useful in interviews & debugging

âœ… 4ï¸âƒ£ Check What Objects Depend on a TYPE (CRITICAL)
SELECT name, type
FROM user_dependencies
WHERE referenced_name = 'SKILL_TAB';

Example Output
EMPLOYEES   TABLE


ğŸ‘‰ Means employees table uses this type

âœ… 5ï¸âƒ£ Check If TYPE Is Used in a Table Column
SELECT table_name, column_name, data_type
FROM user_tab_columns
WHERE data_type = 'SKILL_TAB';


âœ” Confirms where the nested table is used

âœ… 6ï¸âƒ£ Check Storage Table of Nested Table
SELECT table_name
FROM user_nested_tables
WHERE column_name = 'SKILLS';

Example Output
EMP_SKILLS_NT


ğŸ‘‰ This is the physical storage table

âœ… 7ï¸âƒ£ Check ALL Nested Tables in Schema
SELECT parent_table_name,
       parent_table_column,
       table_name AS storage_table
FROM user_nested_tables;
-----------------------------------------------------------------------------------

ğŸ—‘ï¸ HOW TO DROP TYPE IN ORACLE
âœ… 1ï¸âƒ£ Basic Syntax (When NO Dependencies)
ğŸ”¹ Syntax
DROP TYPE type_name;

ğŸ”¹ Example
DROP TYPE skill_tab;


âœ” Works only if the type is NOT used anywhere
âœ” Safe and clean

âŒ If TYPE Is Used â†’ Error

If skill_tab is used in a table or procedure:

ORA-02303: cannot drop or replace a type with table dependents

âœ… 2ï¸âƒ£ Drop TYPE with FORCE (IMPORTANT)
ğŸ”¹ Syntax
DROP TYPE type_name FORCE;

ğŸ”¹ Example
DROP TYPE skill_tab FORCE;

ğŸ” What FORCE Does

Drops the type even if dependencies exist

Invalidates:

Tables

Procedures

Functions

Packages

âš ï¸ Dangerous in production

ğŸ¢ Company-Standard SAFE Way (BEST PRACTICE)
Step 1ï¸âƒ£ Check Dependencies
SELECT name, type
FROM user_dependencies
WHERE referenced_name = 'SKILL_TAB';

Step 2ï¸âƒ£ Drop Dependent Objects First
DROP TABLE employees;


(or procedures, packages using the type)

Step 3ï¸âƒ£ Drop the TYPE
DROP TYPE skill_tab;


âœ” Clean
âœ” No broken objects

âœ… 3ï¸âƒ£ Drop Nested Table Storage Table (Automatic)

When you drop the parent table:

DROP TABLE employees;


âœ” Oracle automatically drops

emp_skills_nt


(No need to drop manually)

ğŸ” 4ï¸âƒ£ Full Cleanup Example (Real Project)

DROP TABLE employees;

DROP TYPE skill_tab;


-------------------------------------------------------------------------

ğŸ‘‰ Create Nested Table â†’ INSERT â†’ SELECT â†’ UPDATE â†’ DELETE
All steps are real-time usable + interview ready.



ğŸ”¹ STEP 1: Create Nested Table TYPE

CREATE OR REPLACE TYPE skill_tab IS TABLE OF VARCHAR2(50);
/


âœ” Database-level collection type
âœ” Reusable across tables, procedures



ğŸ”¹ STEP 2: Create Table Using Nested Table

CREATE TABLE employees (
  emp_id   NUMBER PRIMARY KEY,
  emp_name VARCHAR2(50),
  skills   skill_tab
)
NESTED TABLE skills STORE AS emp_skills_nt;


âœ” emp_skills_nt â†’ internal storage table
âœ” One employee â†’ many skills


ğŸ”¹ STEP 3: INSERT (DML â€“ INSERT)

ğŸ”¸ Insert full nested table
INSERT INTO employees
VALUES (
  101,
  'Dharma',
  skill_tab('PLSQL', 'Oracle', 'MongoDB')
);

INSERT INTO employees
VALUES (
  102,
  'Manu',
  skill_tab('SQL', 'JAVA', 'Spring Boot')
);
INSERT INTO employees
VALUES (
  103,
  'Manu',
  skill_tab('python')
);

